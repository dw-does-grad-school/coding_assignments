import os, sys, random, time

# This imports from a file that will be present in the
# grading system. No need to alter for local testing -
# if the file isn't present then these lines are skipped
try:
    from compile_with_soln import grader_stub
    grader = grader_stub()
except:
    pass

N = 0   # number of points

# ----------------------------------------
# This function (which will be compiled with our code
# when submitted to the grading system) takes the index
# of a data point (in 0..N-1) and returns a list of
# indices of neighboring points
# grader.get_neighbors(i);
# ----------------------------------------

def get_neighbors_local(i):
    global N
    if i < 0 or i >= N:
        print("get_neighbors_local: Invalid point index!")
        sys.exit(0)
        
    if N % 2 == 1:
        print("get_neighbors_local: Please set N to an even value, since the test cases generated by this function have a structure depending on N being even.")
        sys.exit(0)
    answer = []
    answer.append(i + 1 - (i % 2) * 2)
    for j in range(N // 2):
        nbr = i % 2 + j * 2
        if nbr != i and abs(nbr - i) < N // 2:
            answer.append(nbr)
    return answer

# ----------------------------------------
# Compute the squared wire length objective for a given ordering
# ----------------------------------------

def squared_wire_length_objective(V):
    global N
    where = [None] * N
    # where[i] is the index in V at which data point i resides
    for i in range(N):
        where[V[i]] = i
    total = 0
    for i in range(N):
        for j in get_neighbors_local(i):  # Switch to grader.get_neighbors() when you submit
            d = where[i] - where[j]
            total += d * d
    return total / 2  # divide by 2 since we count each distance above twice

# ----------------------------------------
# Local search method to improve the ordering
# ----------------------------------------

def local_search(order):
    best_order = order[:]
    best_cost = squared_wire_length_objective(order)

    n = len(order)
    for i in range(n):
        for j in range(i + 1, n):
            # Swap nodes i and j
            new_order = order[:]
            new_order[i], new_order[j] = new_order[j], new_order[i]

            new_cost = squared_wire_length_objective(new_order)
            if new_cost < best_cost:
                best_cost = new_cost
                best_order = new_order

    return best_order, best_cost

# ----------------------------------------
# Main function that runs the optimization
# ----------------------------------------

def main():
    global N
    # The value for N is set in the grading system through an
    # environment variable, if present. If not, set N to any value
    # you want for local testing.
    try:
        N = int(os.environ["N"])
    except:
        N = 20  # Default for local testing

    start_time = time.time()
    best_order = []
    best_cost = float('inf')

    # Initial random ordering
    order = list(range(N))

    # Main loop: Improve the ordering while time allows
    while True:
        # Step 1: Perform local search to refine the ordering
        order, cost = local_search(order)

        # Track the best ordering found
        if cost < best_cost:
            best_cost = cost
            best_order = order

        # Step 2: Check time elapsed
        elapsed = time.time() - start_time
        if elapsed > 28.0:
            break

    # Print the best ordering found
    print(" ".join(map(str, best_order)))

if __name__ == "__main__":
    main()
