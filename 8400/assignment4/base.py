import os, sys, random, time

# This imports from a file that will be present in the
# grading system. No need to alter for local testing -
# if the file isn't present then these lines are skipped
try:
    from compile_with_soln import grader_stub
    grader = grader_stub()
except:
    pass

N = 0   # number of points

# ----------------------------------------
# This function (which will be compiled with our code
# when submitted to the grading system) takes the index
# of a data point (in 0..N-1) and returns a list of
# indices of neighboring points

# grader.get_neighbors(i);
# ----------------------------------------


# ----------------------------------------
# For testing on your own system, you can call this function
# instead.  It builds an instance for which the optimal
# solution consists of a block of even-indexed points
# 0, 2, 4, ..., followed by a block of odd-indexed points
# 1, 3, 5, ... (note that the reversal of this is also
# equally optimal).
# ----------------------------------------

def get_neighbors_local(i):
    global N
    if i < 0 or i >= N:
        print("get_neighbors_local: Invalid point index!")
        sys.exit(0)
        
    if N % 2 == 1:
        print("get_neighbors_local: Please set N to an even value, since the test cases generated by this function have a structure depending on N being even (note that N doesn't need to be even for the real test cases).")
        sys.exit(0)
    answer = []
    answer.append(i + 1 - (i%2)*2)
    for j in range(N//2):
        nbr = i%2 + j*2
        if nbr != i and abs(nbr - i) < N//2:
            answer.append(nbr)
    return answer
    
# Shouldn't need to alter this function except to switch
# from local grader function to grader.get_neighbors()
# when you submit.
def squared_wire_length_objective(V):
    global N
    where = [None]*N
    # where[i] is the index in V at which data point i resides
    for i in range(N):
        where[V[i]] = i
    total = 0
    for i in range(N):
        for j in get_neighbors_local(i): # Switch to grader.get_neighbors() when you submit
            d = where[i] - where[j]
            total += d*d
    return total/2 # divide by 2 since we count each distance above twice

def main():
    global N
    # The value for N is set in the grading system through an
    # environment variable, if present.  If not present, feel
    # welcome to set N to any value you want for local testing.
    try:
        N = int(os.environ["N"])
    except:
        N = 20

    # Below is the part of main() you should modify.
    # (you are welcome to write other functions above
    # and call them here, but all your code should be
    # submitted in this one file).
    # This code (which you should replace) just tries
    # random orderings (random permutations of 0..N-1)
    # until more than 28 seconds have elapsed, then
    # prints out whichever achieves the lowest objective
    # value.

    # NOTE: Please make sure to not change the amount
    # of time you should wait before printing - any
    # longer and you run the risk of your code timing
    # out for the testcase and not receiving credit.

    #start_time = os.times().elapsed
    start_time = time.time()
    best_order = []
    order = []
    best_cost = -1
    while True:
        order = [None]*N
        for i in range(N):
            order[i] = i
            # start with initial order 0,1,2,3,...
            # then swap each element with a random preceding element
            # this makes the entire array a random permutation of 0...N-1
            random_idx = random.randint(0, sys.maxsize) % (i+1)
            order[i], order[random_idx] = order[random_idx], order[i]
        cost = squared_wire_length_objective(order)
        if best_cost == -1 or cost < best_cost:
            best_cost = cost
            best_order = order # remember best ordering so far...

        # It's recommended to NOT make this call every single iteration -
        # this is a system call and is actually rather slow compared
        # to other commands. Instead, check every hundred iterations or so.
        # How often you check may need to be fine tuned in order to not time
        # out on the autograding system.
        #elapsed = os.times().elapsed - start_time
        elapsed = time.time() - start_time

        # Break out of the loop after 28 seconds
        # DO NOT increase the "28.0" - you risk your code timing out if you do
        if elapsed > 28.0:
            break

    # At the end, you should print out a sequence of points
    # (a permutation of 0..N-1) delimited by whitespace
    print(" ".join(map(str, best_order)))

if __name__ == "__main__":
    main()
